#include <iostream>
#include <vector>
#include <limits>
#include <ctime>
#include <cstdlib>
#include <unordered_set>
#include <tuple>

using namespace std;

const int INF = numeric_limits<int>::max();

// Estructura para representar una arista del grafo
struct Arista {
    int destino;  // Nodo destino de la arista
    int peso;     // Peso de la arista
};

typedef vector<vector<Arista>> Grafo;  // Definición del tipo de dato para el grafo

// Implementación de un Heap Binario desde cero usando tuplas
class HeapBinario {
public:
    HeapBinario(int n) {
        data.reserve(n);  // Reserva espacio para n elementos
    }

    bool estaVacio() const {
        return data.empty();  // Retorna true si el heap está vacío
    }

    void insertar(int distancia, int nodo) {
        data.push_back(make_tuple(distancia, nodo));  // Inserta un nuevo elemento
        disminuirClave(data.size() - 1);    // Ajusta la posición del nuevo elemento
    }

    tuple<int, int> extraerMinimo() {
        if (data.empty()) {
            return make_tuple(INF, -1);  // Retorna un valor inválido si el heap está vacío
        }
        tuple<int, int> minElement = data[0];
        data[0] = data.back();
        data.pop_back();
        heapificar(0);  // Mantiene la propiedad del heap
        return minElement;
    }

    void disminuirClave(int i) {
        while (i > 0 && get<0>(data[padre(i)]) > get<0>(data[i])) {
            swap(data[i], data[padre(i)]);
            i = padre(i);
        }
    }

private:
    vector<tuple<int, int>> data;  // Vector para almacenar los elementos del heap

    int padre(int i) const {
        return (i - 1) / 2;
    }

    int izquierdo(int i) const {
        return 2 * i + 1;
    }

    int derecho(int i) const {
        return 2 * i + 2;
    }

    void heapificar(int i) {
        int l = izquierdo(i);
        int r = derecho(i);
        int menor = i;
        if (l < data.size() && get<0>(data[l]) < get<0>(data[menor])) {
            menor = l;
        }
        if (r < data.size() && get<0>(data[r]) < get<0>(data[menor])) {
            menor = r;
        }
        if (menor != i) {
            swap(data[i], data[menor]);
            heapificar(menor);
        }
    }
};

// Implementación del algoritmo de Dijkstra utilizando un Heap Binario
vector<int> dijkstraHeap(const Grafo& grafo, int origen) {
    int n = grafo.size();
    vector<int> dist(n, INF);
    dist[origen] = 0;
    HeapBinario pq(n);
    pq.insertar(0, origen);

    while (!pq.estaVacio()) {
        auto [distU, u] = pq.extraerMinimo();
        for (const auto& arista : grafo[u]) {
            int v = arista.destino;
            int peso = arista.peso;
            if (distU + peso < dist[v]) {
                dist[v] = distU + peso;
                pq.insertar(dist[v], v);
            }
        }
    }

    return dist;
}

// Generación de un grafo aleatorio
Grafo generarGrafo(int numVertices, int numAristas) {
    if (numVertices <= 0 || numAristas <= 0) {
        cerr << "El número de vértices y aristas debe ser mayor que 0." << endl;
        exit(1);
    }

    Grafo grafo(numVertices);
    srand(time(0));

    // Generar árbol cobertor para asegurar conectividad
    for (int i = 1; i < numVertices; ++i) {
        int j = rand() % i;
        int peso = rand() % 100 + 1;
        grafo[i].push_back({j, peso});
        grafo[j].push_back({i, peso});
    }

    unordered_set<string> aristas;
    for (int i = 1; i < numVertices; ++i) {
        aristas.insert(to_string(min(i, i-1)) + "-" + to_string(max(i, i-1)));
    }

    // Añadir aristas adicionales hasta llegar a numAristas aristas
    int aristasAgregadas = numVertices - 1;
    while (aristasAgregadas < numAristas) {
        int u = rand() % numVertices;
        int v = rand() % numVertices;
        if (u != v) {
            string aristaStr = to_string(min(u, v)) + "-" + to_string(max(u, v));
            if (aristas.find(aristaStr) == aristas.end()) {
                int peso = rand() % 100 + 1;
                grafo[u].push_back({v, peso});
                grafo[v].push_back({u, peso});
                aristas.insert(aristaStr);
                aristasAgregadas++;
            }
        }
    }
    return grafo;
}

// Realización de experimentos
void realizarExperimento() {
    vector<int> is = {10, 12, 14};
    for (int i : is) {
        int numVertices = 1 << i;
        vector<int> js;
        if (i == 10) {
            js = {16, 17, 18};  // Para i = 10, probar solo j = 16, 17, 18
        } else {
            js = {16, 17, 18, 19, 20, 21, 22};  // Para i = 12 y i = 14, probar j = 16, 17, ... 22
        }
        for (int j : js) {
            int numAristas = 1 << j;
            double tiempoTotal = 0;
            for (int k = 0; k < 50; ++k) {
                Grafo grafo = generarGrafo(numVertices, numAristas);
                int origen = rand() % numVertices;
                clock_t inicio = clock();
                dijkstraHeap(grafo, origen);
                clock_t fin = clock();
                tiempoTotal += double(fin - inicio) / CLOCKS_PER_SEC;
            }
            cout << "i: " << i << ", j: " << j << ", Tiempo Promedio: " << tiempoTotal / 50 << " segundos" << endl;
        }
    }
}

int main() {
    realizarExperimento();
    return 0;
}
